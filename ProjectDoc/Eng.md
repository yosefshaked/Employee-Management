# Project Documentation: Employee & Payroll Management System

**Version: 1.0.0**
**Last Updated: 2025-09-07**

## 1. Vision & Purpose

The goal of this project is to provide a user-friendly, efficient, and reliable application for managing employee payroll. It serves as a replacement for an error-prone Excel file, tailored to the specific needs of a business with two main employee types: hourly workers and instructors paid per session.

**Key Requirements:**
- A simple and intuitive user interface (primarily in Hebrew).
- The ability to define dynamic rates that can change over time.
- Flexible management of service types (sessions) that instructors can perform.
- Accurate and interactive reporting.
- Preservation of historical accuracy for all financial data.

---

## 2. Architecture & Technology Stack

The system is built on a modern client-server architecture, packaged as a standalone desktop application.

*   **Desktop Application Shell:**
    *   **Framework:** Electron
    *   **Packaging:** electron-builder
    *   **Features:** Includes a custom launcher for opening the app in its own window or in the user's default browser.

*   **Frontend (Client-Side):** A Single Page Application (SPA) built with:
    *   **Framework:** React
    *   **Routing:** React Router (`HashRouter` for desktop compatibility)
    *   **Build Tool:** Vite
    *   **Styling:** Tailwind CSS
    *   **Component Library:** shadcn/ui

*   **Backend & Database:**
    *   **Platform:** Supabase (Backend-as-a-Service)
    *   **Database:** PostgreSQL
    *   **API:** Auto-generated by Supabase (PostgREST).

*   **Configuration Management:**
    *   API keys are managed via a local `.env` file for security, ensuring no sensitive credentials are committed to version control.

---

## 3. Database Schema

This is the core of the system. The database consists of four primary tables:

### 3.1. `Employees` Table
Contains general information about each employee.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `name` | `text` | Employee's full name | Not NULL |
| `employee_type`| `text` | Employee type ('hourly' or 'instructor') | Not NULL |
| `current_rate` | `numeric` | General hourly rate (relevant **only** for hourly employees) | |
| `is_active` | `boolean`| Whether the employee is currently active | Default: `true` |
| ... | ... | Additional fields: `employee_id`, `phone`, `email`, `start_date`, `notes` | |

### 3.2. `Services` Table
Contains the dynamic list of services/sessions that instructors can perform.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `name` | `text` | Name of the service (e.g., "Therapeutic Riding 30 min") | Not NULL |
| `duration_minutes`| `int8`| Duration of the service in minutes (for hour calculations) | |
| `payment_model` | `text` | Payment model ('fixed_rate' or 'per_student') | Not NULL |
| `color` | `text` | A hex color code (e.g., `#8B5CF6`) for UI display | |

### 3.3. `RateHistory` Table
The most critical table. It stores the historical log of rates for each employee and service.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `employee_id` | `uuid` | References the `Employees` table | **Foreign Key** |
| `service_id` | `uuid` | References the `Services` table | **Foreign Key** |
| `rate` | `numeric` | The rate amount | Not NULL |
| `effective_date`| `date` | The date from which this rate is effective | Not NULL |
| `notes` | `text` | Notes about the rate change | |
| **Composite Unique Constraint** | `UNIQUE` | On columns: `employee_id`, `service_id`, `effective_date` | |

### 3.4. `WorkSessions` Table
The work log. Each row represents a completed work session.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `employee_id` | `uuid` | References the `Employees` table | **Foreign Key** |
| `service_id` | `uuid` | References the `Services` table (for instructors) | **Foreign Key** |
| `date` | `date` | The date the work was performed | Not NULL |
| `hours` | `numeric` | Number of hours (for hourly employees) | |
| `sessions_count`| `int8` | Number of sessions (for instructors) | |
| `students_count`| `int8` | Number of students (for `per_student` model) | |
| `rate_used` | `numeric`| A "snapshot" of the rate used at the time of calculation | |
| `total_payment`| `numeric`| A "snapshot" of the final calculated amount | |

---

## 4. Architectural Decisions & Lessons Learned

Several key decisions were made during development that shaped the system:

1.  **Using a separate `RateHistory` table:** Instead of adding rate columns to the `Employees` table.
    *   **Reasoning:** This provides infinite flexibility for adding new services without altering the database schema. Most importantly, it maintains a **perfectly accurate rate history**, which is essential for retroactive calculations.
    *   **Lesson:** Historical accuracy in financial data outweighs the simplicity of a "flat" data structure.

2.  **Using `upsert` with a composite `onConflict` constraint:** To prevent duplicate rate entries for the same day, we defined a unique constraint on the combination of `employee_id`, `service_id`, and `effective_date`.
    *   **Reasoning:** This allows us to use an efficient `upsert` command that overwrites changes made on the same day, thus preventing database "clutter" and maintaining a single source of truth for any given day.
    *   **Lesson:** Proper use of database constraints simplifies application logic and prevents bugs.

3.  **Making components "smart" and self-sufficient:** A bug where the employee edit form didn't show updated rates was solved by making the `EmployeeForm` component responsible for fetching its own up-to-date data, rather than relying on potentially stale data from its parent.
    *   **Lesson:** It's crucial to manage state wisely and ensure components always work with the most current data they need.

4.  **Prioritizing User Experience (UX):** We debated extensively about form behavior, especially when switching between employee types.
    *   **The Decision:** Instead of a full form reset, we implemented a "smart partial reset" and added a styled `AlertDialog` to give the user full control over actions that could cause data loss.
    *   **Lesson:** A good user experience requires thinking about edge cases and avoiding automatic behaviors that might frustrate the user.

---

## 5. Setup and Deployment Guide

This guide is for a new developer (or AI) joining the project who needs to set up the development environment from scratch.
### Development Setup

1.  **Clone the Repository:** `git clone [repository-url]`
2.  **Install Dependencies:** `npm install`
3.  **Setup Supabase:**
    *   Create a new project on `supabase.com`.
    *   Create the 4 tables (`Employees`, `Services`, `RateHistory`, `WorkSessions`) as specified in Section 3.
    *   Ensure all `Primary Keys`, `Foreign Keys`, and `Constraints` are configured correctly.
4.  **Create Environment File:**
    *   In the root of the project, create a new file named `.env`.
    *   Add your Supabase credentials to this file:
        ---------------------------------------------------------------
        VITE_SUPABASE_URL=https://<your-project-id>.supabase.co
        VITE_SUPABASE_ANON_KEY=<your-anon-key>
        ---------------------------------------------------------------
    *   **Important:** The `.env` file is listed in `.gitignore` and will not be committed.
5.  **Run the Development App:**
    ---------------------
    npm run electron:dev
    ---------------------
    This will launch the application in a desktop window with hot-reloading.

### Building for Production

1.  **Run the build command:**
    ------------------------
    npm run electron:build
    ------------------------
2.  This command will:
    *   Build the React application into the `/dist` folder.
    *   Package the app with Electron into an executable installer.
3.  The final installer/application will be located in the `/release` directory (which is created outside the project folder).