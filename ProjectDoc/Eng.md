# Project Documentation: Employee & Payroll Management System

**Version: 1.3.11**
**Last Updated: 2025-09-13**

## 1. Vision & Purpose

The goal of this project is to provide a user-friendly, efficient, and reliable application for managing employee payroll. It serves as a replacement for an error-prone Excel file, tailored to the specific needs of a business with two main employee types: hourly workers and instructors paid per session.

**Key Requirements:**
- A simple and intuitive user interface (primarily in Hebrew).
- The ability to define dynamic rates that can change over time.
- Flexible management of service types (sessions) that instructors can perform.
- Accurate and interactive reporting.
- Preservation of historical accuracy for all financial data.

---

## 2. Architecture & Technology Stack

The system is built on a modern client-server architecture, packaged as a standalone desktop application.

*   **Desktop Application Shell:**
    *   **Framework:** Electron
    *   **Packaging:** electron-builder
    *   **Features:** Includes a custom launcher for opening the app in its own window or in the user's default browser.

*   **Frontend (Client-Side):** A Single Page Application (SPA) built with:
    *   **Framework:** React
    *   **Routing:** React Router (`HashRouter` for desktop compatibility)
    *   **Build Tool:** Vite
    *   **Styling:** Tailwind CSS
    *   **Component Library:** shadcn/ui

*   **Backend & Database:**
    *   **Platform:** Supabase (Backend-as-a-Service)
    *   **Database:** PostgreSQL
    *   **API:** Auto-generated by Supabase (PostgREST).

*   **Configuration Management:**
    *   API keys are managed via a local `.env` file for security, ensuring no sensitive credentials are committed to version control.

---

## 3. Database Schema

This is the core of the system. The database consists of four primary tables:

### 3.1. `Employees` Table
Contains general information about each employee.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `name` | `text` | Employee's full name | Not NULL |
| `employee_type`| `text` | Employee type ('hourly', 'instructor', 'global') | Not NULL |
| `current_rate` | `numeric` | General hourly or monthly rate snapshot | |
| `working_days` | `jsonb` | Array of working day codes (e.g., `["SUN","MON"]`) | Default: `["SUN","MON","TUE","WED","THU"]` |
| `is_active` | `boolean`| Whether the employee is currently active | Default: `true` |
| ... | ... | Additional fields: `employee_id`, `phone`, `email`, `start_date`, `notes` | |

### 3.2. `Services` Table
Contains the dynamic list of services/sessions that instructors can perform.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `name` | `text` | Name of the service (e.g., "Therapeutic Riding 30 min") | Not NULL |
| `duration_minutes`| `int8`| Duration of the service in minutes (for hour calculations) | |
| `payment_model` | `text` | Payment model ('fixed_rate' or 'per_student') | Not NULL |
| `color` | `text` | A hex color code (e.g., `#8B5CF6`) for UI display | |

### 3.3. `RateHistory` Table
The most critical table. It stores the historical log of rates for each employee and service.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `employee_id` | `uuid` | References the `Employees` table | **Foreign Key** |
| `service_id` | `uuid` | References the `Services` table | **Foreign Key** |
| `rate` | `numeric` | The rate amount | Not NULL |
| `effective_date`| `date` | The date from which this rate is effective | Not NULL |
| `notes` | `text` | Notes about the rate change | |
| **Composite Unique Constraint** | `UNIQUE` | On columns: `employee_id`, `service_id`, `effective_date` | |

### 3.4. `WorkSessions` Table
The work log. Each row represents a completed work session.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `employee_id` | `uuid` | References the `Employees` table | **Foreign Key** |
| `service_id` | `uuid` | References the `Services` table (for instructors) | **Foreign Key** |
| `date` | `date` | The date the work was performed | Not NULL |
| `entry_type` | `text` | 'session', 'hours', 'adjustment', or 'paid_leave' | Not NULL |
| `hours` | `numeric` | Number of hours (display-only for globals) | |
| `sessions_count`| `int8` | Number of sessions (for instructors) | |
| `students_count`| `int8` | Number of students (for `per_student` model) | |
| `rate_used` | `numeric`| A "snapshot" of the rate used at the time of calculation | |
| `total_payment`| `numeric`| A "snapshot" of the final calculated amount | |

#### WorkSessions Calculation Rules

- `rate_used` is loaded from `RateHistory` on each create/update. Instructors resolve it by `(employee_id, service_id, date)`; hourly and global employees resolve it by `(employee_id, date)`.
- `service_id` is mandatory for instructor sessions. Saving is blocked if no matching rate exists for the date.
- `effectiveWorkingDays(employee, month)` counts calendar days whose weekday exists in `employee.working_days`. If the result is `0`, saving is blocked.
- `total_payment` is computed per row and stored:
  - Instructors: `sessions_count * students_count * rate_used` (or without students when not per-student).
  - Hourly employees: `hours * rate_used`.
  - Global hours: `monthly_rate / effectiveWorkingDays(employee, month)` (each row represents one day; hours field is ignored and multiple rows on the same date count once).
  - Paid leave: same daily rate as global hours, stored with `entry_type='paid_leave'`.
  - Monthly totals and reports sum `total_payment` from `WorkSessions` rows only, deduplicating global rows by day; no external base salary is added.
  - Unpaid absence = no row. Paid leave is explicitly recorded with an `entry_type='paid_leave'` row.
  - Each row may include optional `notes` (free text, max 300 chars).

### Multi-date Quick Entry UX

Users can enable **"בחר תאריכים להזנה מרובה"** in the time-entry table to select multiple dates and employees. Clicking **"הזן"** opens a modal listing all selected dates as stacked mini-forms—one row per date and employee. Each field has an **"העתק מהרישום הקודם"** button to copy from the previous row.
Global employees see an hours field for reference only and a toggle between regular day and paid leave; pay is still one daily rate per row.
Saving creates a `WorkSessions` record for every employee × date combination selected.

### Hebrew Data Import

The import modal supports either pasting text or uploading a `.csv` file. Lines starting with `#` are treated as comments and skipped. The employee is chosen inside the modal; the file must not contain an employee column. Supported delimiters are comma, TAB, semicolon and pipe—auto detected with a manual override.

**Header Mapping**

| Hebrew             | Internal field |
|-------------------|----------------|
| תאריך            | `date` (DD/MM/YYYY → YYYY-MM-DD) |
| סוג רישום        | `entry_type` (`שיעור`=`session`, `שעות`=`hours`, `התאמה`=`adjustment`, `חופשה בתשלום`=`paid_leave`) |
| שירות            | `service_name` |
| שעות             | `hours` |
| מספר שיעורים     | `sessions_count` |
| מספר תלמידים     | `students_count` |
| סכום התאמה       | `adjustment_amount` |
| הערות            | `notes` |

The preview shows up to 100 rows with per-row error messages. Duplicate rows are flagged and skipped unless the user opts in to import them.

**Templates**

Buttons in the modal allow downloading a CSV template (UTF‑8 with BOM) and a basic Excel placeholder. Both templates include instructional comment lines and example rows marked “(דוגמה)” that should be deleted before upload.

**Validation Rules**

- `date` must parse to ISO format.
- `session` rows require `service_name`, `sessions_count` ≥1, `students_count` ≥1 and a rate snapshot.
- `hours` rows require a rate snapshot; hourly employees must supply `hours`, while global employees ignore it and use a daily rate.
- `paid_leave` rows are allowed only for global employees and use the global daily rate.
- `adjustment` rows require an `adjustment_amount` and ignore other fields.

Only valid rows are inserted into `WorkSessions`; the summary dialog lists inserted, failed and skipped rows.

### Global Single-Day Editor
- When editing a global employee for a specific date, the modal aggregates all segments under one day header. A single day type selector controls the entire day, and adding hour segments does **not** multiply pay. Removing the last segment is blocked with a notice.
- The month view sums the hours of all segments per day for global employees, showing `X שעות` while pay remains counted once per day.

---

## 4. Architectural Decisions & Lessons Learned

Several key decisions were made during development that shaped the system:

1.  **Using a separate `RateHistory` table:** Instead of adding rate columns to the `Employees` table.
    *   **Reasoning:** This provides infinite flexibility for adding new services without altering the database schema. Most importantly, it maintains a **perfectly accurate rate history**, which is essential for retroactive calculations.
    *   **Lesson:** Historical accuracy in financial data outweighs the simplicity of a "flat" data structure.

2.  **Using `upsert` with a composite `onConflict` constraint:** To prevent duplicate rate entries for the same day, we defined a unique constraint on the combination of `employee_id`, `service_id`, and `effective_date`.
    *   **Reasoning:** This allows us to use an efficient `upsert` command that overwrites changes made on the same day, thus preventing database "clutter" and maintaining a single source of truth for any given day.
    *   **Lesson:** Proper use of database constraints simplifies application logic and prevents bugs.

3.  **Making components "smart" and self-sufficient:** A bug where the employee edit form didn't show updated rates was solved by making the `EmployeeForm` component responsible for fetching its own up-to-date data, rather than relying on potentially stale data from its parent.
    *   **Lesson:** It's crucial to manage state wisely and ensure components always work with the most current data they need.

4.  **Prioritizing User Experience (UX):** We debated extensively about form behavior, especially when switching between employee types.
    *   **The Decision:** Instead of a full form reset, we implemented a "smart partial reset" and added a styled `AlertDialog` to give the user full control over actions that could cause data loss.
    *   **Lesson:** A good user experience requires thinking about edge cases and avoiding automatic behaviors that might frustrate the user.

5.  **Centralized rate history management:** A dedicated `RateHistoryManager` component lets admins add or edit historical rates directly from an employee's form; deletion is intentionally disabled to preserve audit history.
    *   **Lesson:** Consolidating rate edits in one place keeps payroll data consistent and transparent.

---

## 5. Setup and Deployment Guide

This guide is for a new developer (or AI) joining the project who needs to set up the development environment from scratch.
### Development Setup

1.  **Clone the Repository:** `git clone [repository-url]`
2.  **Install Dependencies:** `npm install`
3.  **Setup Supabase:**
    *   Create a new project on `supabase.com`.
    *   Create the 4 tables (`Employees`, `Services`, `RateHistory`, `WorkSessions`) as specified in Section 3.
    *   Ensure all `Primary Keys`, `Foreign Keys`, and `Constraints` are configured correctly.
4.  **Create Environment File:**
    *   In the root of the project, create a new file named `.env`.
    *   Add your Supabase credentials to this file:
        ---------------------------------------------------------------
        VITE_SUPABASE_URL=https://<your-project-id>.supabase.co
        VITE_SUPABASE_ANON_KEY=<your-anon-key>
        ---------------------------------------------------------------
    *   **Important:** The `.env` file is listed in `.gitignore` and will not be committed.
5.  **Run the Development App:**
    ---------------------
    npm run electron:dev
    ---------------------
    This will launch the application in a desktop window with hot-reloading.

### Building for Production

1.  **Run the build command:**
    ------------------------
    npm run electron:build
    ------------------------
2.  This command will:
    *   Build the React application into the `/dist` folder.
    *   Package the app with Electron into an executable installer.
3.  The final installer/application will be located in the `/release` directory (which is created outside the project folder).

## Recent Updates

- Date filters in reports accept manual input or calendar selection and support multiple formats.
- Hours KPI counts time for hourly employees only; employee type filter now includes global staff.
- Detailed entries report can group by employee type with subtotals.