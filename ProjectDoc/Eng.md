# Project Documentation: Employee & Payroll Management System

**Version: 1.5.2**
**Last Updated: 2025-10-07**

## 1. Vision & Purpose

The goal of this project is to provide a user-friendly, efficient, and reliable application for managing employee payroll. It serves as a replacement for an error-prone Excel file, tailored to the specific needs of a business with two main employee types: hourly workers and instructors paid per session.

**Key Requirements:**
- A simple and intuitive user interface (primarily in Hebrew).
- The ability to define dynamic rates that can change over time.
- Flexible management of service types (sessions) that instructors can perform.
- Accurate and interactive reporting.
- Preservation of historical accuracy for all financial data.

---

## 2. Architecture & Technology Stack

The system is built on a modern client-server architecture, packaged as a standalone desktop application.

*   **Desktop Application Shell:**
    *   **Framework:** Electron
    *   **Packaging:** electron-builder
    *   **Features:** Includes a custom launcher for opening the app in its own window or in the user's default browser.

*   **Frontend (Client-Side):** A Single Page Application (SPA) built with:
    *   **Framework:** React
    *   **Routing:** React Router (`HashRouter` for desktop compatibility)
    *   **Build Tool:** Vite
    *   **Styling:** Tailwind CSS
    *   **Component Library:** shadcn/ui

*   **Backend & Database:**
    *   **Platform:** Supabase (Backend-as-a-Service)
    *   **Database:** PostgreSQL
    *   **API:** Auto-generated by Supabase (PostgREST).

*   **Configuration Management:**
    *   Runtime credentials load exclusively from the `/api/config` Azure Function. Without a bearer token the function returns the core Supabase URL and anon key defined by `APP_SUPABASE_URL` and `APP_SUPABASE_ANON_KEY`.
    *   Organization-specific Supabase URLs and anon keys are resolved on demand through the same endpoint once the client supplies `Authorization: Bearer <token>` and `x-org-id` headers. The function validates membership using `APP_SUPABASE_SERVICE_ROLE` before returning secrets.

### 2.1. Organization & Membership Model

- The desktop shell keeps a dedicated Supabase project for application metadata. Core tables include `app_organizations`, `app_org_memberships`, and `app_org_invitations`.
- Each organization row stores the Supabase connection (`supabase_url`, `supabase_anon_key`), optional `policy_links` (array of URLs), `legal_settings` (JSON payload for contact email, terms, privacy policy), and lifecycle markers (`setup_completed`, `verified_at`).
- Membership rows link Supabase Auth `user_id` values to an organization with a `role` (`admin` or `member`). Each user currently belongs to a single organization; switching orgs rewires the runtime Supabase client to the selected connection.
- Invitation rows record pending emails. Admins can issue invites from **Settings → Org Members**, revoke pending ones, or remove existing members (except themselves).
- On login the `OrgProvider` loads the user’s memberships, persists the last selected org in `localStorage`, and ensures routes without a saved connection redirect to **Settings** so the Setup Assistant can finish configuration.

---

## 3. Database Schema

This is the core of the system. The database consists of four primary tables:

### 3.1. `Employees` Table
Contains general information about each employee.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `name` | `text` | Employee's full name | Not NULL |
| `employee_type`| `text` | Employee type ('hourly', 'instructor', 'global') | Not NULL |
| `current_rate` | `numeric` | General hourly or monthly rate snapshot | |
| `working_days` | `jsonb` | Array of working day codes (e.g., `["SUN","MON"]`) | Default: `["SUN","MON","TUE","WED","THU"]` |
| `is_active` | `boolean`| Whether the employee is currently active | Default: `true` |
| ... | ... | Additional fields: `employee_id`, `phone`, `email`, `start_date`, `notes` | |

### 3.2. `Services` Table
Contains the dynamic list of services/sessions that instructors can perform.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `name` | `text` | Name of the service (e.g., "Therapeutic Riding 30 min") | Not NULL |
| `duration_minutes`| `int8`| Duration of the service in minutes (for hour calculations) | |
| `payment_model` | `text` | Payment model ('fixed_rate' or 'per_student') | Not NULL |
| `color` | `text` | A hex color code (e.g., `#8B5CF6`) for UI display | |

### 3.3. `RateHistory` Table
The most critical table. It stores the historical log of rates for each employee and service.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `employee_id` | `uuid` | References the `Employees` table | **Foreign Key** |
| `service_id` | `uuid` | References the `Services` table | **Foreign Key** |
| `rate` | `numeric` | The rate amount | Not NULL |
| `effective_date`| `date` | The date from which this rate is effective | Not NULL |
| `notes` | `text` | Notes about the rate change | |
| **Composite Unique Constraint** | `UNIQUE` | On columns: `employee_id`, `service_id`, `effective_date` | |

### 3.4. `WorkSessions` Table
The work log. Each row represents a completed work session.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `employee_id` | `uuid` | References the `Employees` table | **Foreign Key** |
| `service_id` | `uuid` | References the `Services` table (for instructors) | **Foreign Key** |
| `date` | `date` | The date the work was performed | Not NULL |
| `entry_type` | `text` | 'session', 'hours', 'adjustment', or 'paid_leave' | Not NULL |
| `hours` | `numeric` | Number of hours (display-only for globals) | |
| `sessions_count`| `int8` | Number of sessions (for instructors) | |
| `students_count`| `int8` | Number of students (for `per_student` model) | |
| `rate_used` | `numeric`| A "snapshot" of the rate used at the time of calculation | |
| `total_payment`| `numeric`| A "snapshot" of the final calculated amount | |

#### WorkSessions Calculation Rules

- `rate_used` is loaded from `RateHistory` on each create/update. Instructors resolve it by `(employee_id, service_id, date)`; hourly and global employees resolve it by `(employee_id, date)`.
- `service_id` is mandatory for instructor sessions. Saving is blocked if no matching rate exists for the date.
- `effectiveWorkingDays(employee, month)` counts calendar days whose weekday exists in `employee.working_days`. If the result is `0`, saving is blocked.
- `total_payment` is computed per row and stored:
  - Instructors: `sessions_count * students_count * rate_used` (or without students when not per-student).
  - Hourly employees: `hours * rate_used`.
  - Global hours: `monthly_rate / effectiveWorkingDays(employee, month)` (each row represents one day; hours field is ignored and multiple rows on the same date count once).
  - Paid leave: same daily rate as global hours, stored with `entry_type='paid_leave'`.
  - Monthly totals and reports sum `total_payment` from `WorkSessions` rows only, deduplicating global rows by day; no external base salary is added.
  - Unpaid absence = no row. Paid leave is explicitly recorded with an `entry_type='paid_leave'` row.
  - Each row may include optional `notes` (free text, max 300 chars).

### 3.5. `Settings` Table
Stores organization-wide configuration values, accessed via a stable `key`.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `uuid` | Auto-generated unique identifier | **Primary Key** |
| `key` | `text` | Settings bucket identifier (e.g., `leave_policy`) | **Unique** |
| `settings_value` | `jsonb` | Structured JSON payload for the setting | Not NULL |
| `created_at` | `timestamptz` | Creation timestamp | Default: `now()` |
| `updated_at` | `timestamptz` | Last update timestamp | Default: `now()` |

The `leave_policy` record contains the leave-management configuration consumed across the app:

- `allow_half_day` – allow employees to consume 0.5 day at a time.
- `allow_negative_balance` – enable overdraft until reaching the configured floor.
- `negative_floor_days` – minimum balance allowed (negative values represent how far below zero the balance may go).
- `carryover_enabled` / `carryover_max_days` – governs how many unused days roll into the next year.
- `holiday_rules[]` – array of `{ id, name, type, start_date, end_date, recurrence }` objects that mark holiday ranges and tag them as system-paid, employee-paid, unpaid, mixed, or half-day.

All read/write operations should reuse the helpers in `src/lib/leave.js` to normalize the JSON and guarantee consistent IDs.

### 3.6. `LeaveBalances` Table
Acts as the immutable ledger for employee leave allocations and usage.

| Column | Type | Description | Constraints |
| :--- | :--- | :--- | :--- |
| `id` | `bigint` | Auto-incrementing identifier | **Primary Key** |
| `employee_id` | `uuid` | References the `Employees` table | **Foreign Key** |
| `leave_type` | `text` | Context for the entry (e.g., `allocation`, `usage_employee_paid`, `time_entry_leave_employee_paid`) | Not NULL |
| `balance` | `numeric` | Positive values add quota, negative values deduct usage | Not NULL, Default `0` |
| `effective_date` | `date` | Effective date of the leave event | Not NULL |
| `notes` | `text` | Optional free-form details | |
| `created_at` | `timestamptz` | Insert timestamp | Default: `now()` |

Ledger entries support fractional values (e.g., `-0.5` for half-day usage when policy allows it). Negative entries representing usage are validated against the configured floor before insert; attempts to exceed the overdraft surface the toast "חריגה ממכסה ימי החופשה המותרים" and are rejected.

### Multi-date Quick Entry UX

Users can enable **"בחר תאריכים להזנה מרובה"** in the time-entry table to select multiple dates and employees. Clicking **"הזן"** opens a modal listing all selected dates as stacked mini-forms—one row per date and employee. Each field has an **"העתק מהרישום הקודם"** button to copy from the previous row.
Global employees see an hours field for reference only and a toggle between regular day and paid leave; pay is still one daily rate per row.
Saving creates a `WorkSessions` record for every employee × date combination selected.

### Hebrew Data Import

The import modal supports either pasting text or uploading a `.csv` file. Lines starting with `#` are treated as comments and skipped. The employee is chosen inside the modal; the file must not contain an employee column. Supported delimiters are comma, TAB, semicolon and pipe—auto detected with a manual override.

**Header Mapping**

| Hebrew             | Internal field |
|-------------------|----------------|
| תאריך            | `date` (DD/MM/YYYY → YYYY-MM-DD) |
| סוג רישום        | `entry_type` (`שיעור`=`session`, `שעות`=`hours`, `התאמה`=`adjustment`, `חופשה בתשלום`=`paid_leave`) |
| שירות            | `service_name` |
| שעות             | `hours` |
| מספר שיעורים     | `sessions_count` |
| מספר תלמידים     | `students_count` |
| סכום התאמה       | `adjustment_amount` |
| הערות            | `notes` |

The preview shows up to 100 rows with per-row error messages. Duplicate rows are flagged and skipped unless the user opts in to import them.

**Templates**

Buttons in the modal allow downloading a CSV template (UTF‑8 with BOM) and a basic Excel placeholder. Both templates include instructional comment lines and example rows marked “(דוגמה)” that should be deleted before upload.

**Validation Rules**

- `date` must parse to ISO format.
- `session` rows require `service_name`, `sessions_count` ≥1, `students_count` ≥1 and a rate snapshot.
- `hours` rows require a rate snapshot; hourly employees must supply `hours`, while global employees ignore it and use a daily rate.
- `paid_leave` rows are allowed only for global employees and use the global daily rate.
- `adjustment` rows require an `adjustment_amount` and ignore other fields.

Only valid rows are inserted into `WorkSessions`; the summary dialog lists inserted, failed and skipped rows.

### Global Single-Day Editor
- When editing a global employee for a specific date, the modal aggregates all segments under one day header. A single day type selector controls the entire day, and adding hour segments does **not** multiply pay. Removing the last segment is blocked with a notice.
- The month view sums the hours of all segments per day for global employees, showing `X שעות` while pay remains counted once per day.

---

## 4. Architectural Decisions & Lessons Learned

Several key decisions were made during development that shaped the system:

1.  **Using a separate `RateHistory` table:** Instead of adding rate columns to the `Employees` table.
    *   **Reasoning:** This provides infinite flexibility for adding new services without altering the database schema. Most importantly, it maintains a **perfectly accurate rate history**, which is essential for retroactive calculations.
    *   **Lesson:** Historical accuracy in financial data outweighs the simplicity of a "flat" data structure.

2.  **Using `upsert` with a composite `onConflict` constraint:** To prevent duplicate rate entries for the same day, we defined a unique constraint on the combination of `employee_id`, `service_id`, and `effective_date`.
    *   **Reasoning:** This allows us to use an efficient `upsert` command that overwrites changes made on the same day, thus preventing database "clutter" and maintaining a single source of truth for any given day.
    *   **Lesson:** Proper use of database constraints simplifies application logic and prevents bugs.

3.  **Making components "smart" and self-sufficient:** A bug where the employee edit form didn't show updated rates was solved by making the `EmployeeForm` component responsible for fetching its own up-to-date data, rather than relying on potentially stale data from its parent.
    *   **Lesson:** It's crucial to manage state wisely and ensure components always work with the most current data they need.

4.  **Prioritizing User Experience (UX):** We debated extensively about form behavior, especially when switching between employee types.
    *   **The Decision:** Instead of a full form reset, we implemented a "smart partial reset" and added a styled `AlertDialog` to give the user full control over actions that could cause data loss.
    *   **Lesson:** A good user experience requires thinking about edge cases and avoiding automatic behaviors that might frustrate the user.

5.  **Centralized rate history management:** A dedicated `RateHistoryManager` component lets admins add or edit historical rates directly from an employee's form; deletion is intentionally disabled to preserve audit history.
    *   **Lesson:** Consolidating rate edits in one place keeps payroll data consistent and transparent.

---

## 5. Setup and Deployment Guide

This guide is for a new developer (or AI) joining the project who needs to set up the development environment from scratch.
### Development Setup

1.  **Clone the Repository:** `git clone [repository-url]`
2.  **Install Dependencies:** `npm install`
3.  **Setup Supabase:**
    *   Create a new project on `supabase.com`.
    *   Create the 4 tables (`Employees`, `Services`, `RateHistory`, `WorkSessions`) as specified in Section 3.
    *   Ensure all `Primary Keys`, `Foreign Keys`, and `Constraints` are configured correctly.

### Organization Onboarding Flow

1. Sign in with Supabase Auth (Google, Microsoft, or email+password).
2. The **Select Organization** screen lists any memberships tied to your account. Create a new organization or accept pending invites to continue.
3. After selecting an organization, open **Settings → Setup Assistant** to store the Supabase URL/anon key and run the guided SQL.
4. Use **Settings → Org Members** to invite additional admins. They will see the invite on the Select Organization screen and inherit the same Supabase connection once accepted.

### Supabase Security Baseline (Row Level Security)

Every customer project must enable row level security (RLS) so that only authenticated users can read or modify data. The in-app Setup Assistant (Settings → Setup Assistant) guides admins through three required steps:

1. **Connect** – enter the Supabase public URL and anon key. The values are saved on the organization record (`app_organizations.supabase_url` / `supabase_anon_key`) together with any policy links or legal metadata so every admin sees the same configuration.
2. **Apply SQL** – run the schema/helper block and the RLS baseline block below (in this order) from the Supabase SQL editor while signed in as the project owner.
3. **Verify** – click “הרץ אימות” in the assistant. It calls the `setup_assistant_diagnostics()` helper with the anon key, reports any missing pieces, and flips `app_organizations.setup_completed` + `verified_at` when everything passes. Routes other than **Settings** remain blocked until this step succeeds.

#### Schema + helper SQL

```sql
-- שלב 1: יצירת סכימה מלאה ו-אובייקט עזר לאימות
set search_path = public;

create extension if not exists "pgcrypto";

create table if not exists public."Employees" (
  "id" uuid not null default gen_random_uuid(),
  "name" text not null,
  "employee_id" text not null,
  "employee_type" text,
  "current_rate" numeric,
  "phone" text,
  "email" text,
  "start_date" date,
  "is_active" boolean default true,
  "notes" text,
  "working_days" jsonb,
  "annual_leave_days" numeric default 12,
  "leave_pay_method" text,
  "leave_fixed_day_rate" numeric,
  "metadata" jsonb,
  constraint "Employees_pkey" primary key ("id")
);

create table if not exists public."Services" (
  "id" uuid not null default gen_random_uuid(),
  "name" text not null,
  "duration_minutes" bigint,
  "payment_model" text,
  "color" text,
  "metadata" jsonb,
  constraint "Services_pkey" primary key ("id")
);

create table if not exists public."RateHistory" (
  "id" uuid not null default gen_random_uuid(),
  "rate" numeric not null,
  "effective_date" date not null,
  "notes" text,
  "employee_id" uuid not null default gen_random_uuid(),
  "service_id" uuid default gen_random_uuid(),
  "metadata" jsonb,
  constraint "RateHistory_pkey" primary key ("id"),
  constraint "RateHistory_employee_id_fkey" foreign key ("employee_id") references public."Employees"("id"),
  constraint "RateHistory_service_id_fkey" foreign key ("service_id") references public."Services"("id")
);

create table if not exists public."WorkSessions" (
  "id" uuid not null default gen_random_uuid(),
  "employee_id" uuid not null default gen_random_uuid(),
  "service_id" uuid default gen_random_uuid(),
  "date" date not null,
  "session_type" text,
  "hours" numeric,
  "sessions_count" bigint,
  "students_count" bigint,
  "rate_used" numeric,
  "total_payment" numeric,
  "notes" text,
  "created_at" timestamptz default now(),
  "entry_type" text not null default 'hours',
  "payable" boolean,
  "metadata" jsonb,
  "deleted" boolean not null default false,
  "deleted_at" timestamptz,
  constraint "WorkSessions_pkey" primary key ("id"),
  constraint "WorkSessions_employee_id_fkey" foreign key ("employee_id") references public."Employees"("id"),
  constraint "WorkSessions_service_id_fkey" foreign key ("service_id") references public."Services"("id")
);

create table if not exists public."LeaveBalances" (
  "id" bigint generated always as identity primary key,
  "created_at" timestamptz not null default now(),
  "employee_id" uuid not null default gen_random_uuid(),
  "leave_type" text not null,
  "balance" numeric not null default 0,
  "effective_date" date not null,
  "notes" text,
  "metadata" jsonb,
  constraint "LeaveBalances_employee_id_fkey" foreign key ("employee_id") references public."Employees"("id")
);

create table if not exists public."Settings" (
  "id" uuid not null default gen_random_uuid(),
  "created_at" timestamptz not null default now(),
  "settings_value" jsonb not null,
  "updated_at" timestamptz default now(),
  "key" text not null unique,
  "metadata" jsonb,
  constraint "Settings_pkey" primary key ("id")
);

create index if not exists "RateHistory_employee_service_idx" on public."RateHistory" ("employee_id", "service_id", "effective_date");
create index if not exists "LeaveBalances_employee_date_idx" on public."LeaveBalances" ("employee_id", "effective_date");
create index if not exists "WorkSessions_employee_date_idx" on public."WorkSessions" ("employee_id", "date");
create index if not exists "WorkSessions_service_idx" on public."WorkSessions" ("service_id");
create index if not exists "WorkSessions_deleted_idx" on public."WorkSessions" ("deleted") where "deleted" = true;

create or replace function public.setup_assistant_diagnostics()
returns table (
  table_name text,
  has_table boolean,
  rls_enabled boolean,
  missing_policies text[],
  delta_sql text
)
language plpgsql
security definer
set search_path = public
as $$
declare
  required_tables constant text[] := array['Employees', 'WorkSessions', 'LeaveBalances', 'RateHistory', 'Services', 'Settings'];
  required_policy_names text[];
  required_commands constant text[] := array['SELECT', 'INSERT', 'UPDATE', 'DELETE'];
  table_reg regclass;
  existing_policies text[];
  idx integer;
begin
  foreach table_name in array required_tables loop
    required_policy_names := array[
      format('Authenticated select %s', table_name),
      format('Authenticated insert %s', table_name),
      format('Authenticated update %s', table_name),
      format('Authenticated delete %s', table_name)
    ];

    table_reg := to_regclass(format('public.%I', table_name));
    has_table := table_reg is not null;
    rls_enabled := false;
    missing_policies := array[]::text[];
    delta_sql := '';

    if not has_table then
      missing_policies := required_policy_names;
      delta_sql := format('-- הטבלה "%s" חסרה. הרץ את בלוק הסכימה המלא.', table_name);
      return next;
      continue;
    end if;

    select coalesce(c.relrowsecurity, false)
      into rls_enabled
    from pg_class c
    where c.oid = table_reg;

    select coalesce(array_agg(policyname order by policyname), array[]::text[])
      into existing_policies
    from pg_policies
    where schemaname = 'public'
      and tablename = lower(table_name);

    missing_policies := array(
      select policy_name
      from unnest(required_policy_names) as policy_name
      where not (policy_name = any(existing_policies))
    );

    if not rls_enabled then
      delta_sql := delta_sql || format('ALTER TABLE public."%s" ENABLE ROW LEVEL SECURITY;', table_name) || E'\\n';
    end if;

    if array_length(missing_policies, 1) is null then
      missing_policies := array[]::text[];
    else
      for idx in 1..array_length(required_policy_names, 1) loop
        if array_position(missing_policies, required_policy_names[idx]) is not null then
          if required_commands[idx] = 'SELECT' then
            delta_sql := delta_sql || format(
              'CREATE POLICY "%s" ON public."%s"%s  FOR SELECT TO authenticated%s  USING (true);%s',
              required_policy_names[idx],
              table_name,
              E'\\n',
              E'\\n',
              E'\\n'
            );
          elsif required_commands[idx] = 'INSERT' then
            delta_sql := delta_sql || format(
              'CREATE POLICY "%s" ON public."%s"%s  FOR INSERT TO authenticated%s  WITH CHECK (true);%s',
              required_policy_names[idx],
              table_name,
              E'\\n',
              E'\\n',
              E'\\n'
            );
          elsif required_commands[idx] = 'UPDATE' then
            delta_sql := delta_sql || format(
              'CREATE POLICY "%s" ON public."%s"%s  FOR UPDATE TO authenticated%s  USING (true)%s  WITH CHECK (true);%s',
              required_policy_names[idx],
              table_name,
              E'\\n',
              E'\\n',
              E'\\n',
              E'\\n'
            );
          elsif required_commands[idx] = 'DELETE' then
            delta_sql := delta_sql || format(
              'CREATE POLICY "%s" ON public."%s"%s  FOR DELETE TO authenticated%s  USING (true);%s',
              required_policy_names[idx],
              table_name,
              E'\\n',
              E'\\n',
              E'\\n'
            );
          end if;
        end if;
      end loop;
    end if;

    if delta_sql = '' then
      delta_sql := null;
    end if;

    return next;
  end loop;

  return;
end;
$$;

grant execute on function public.setup_assistant_diagnostics() to authenticated;
```

#### RLS baseline SQL

```sql
-- שלב 2: הפעלת RLS והוספת מדיניות מאובטחת
alter table public."Employees" enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'Employees'
      and policyname = 'Authenticated select Employees'
  ) then
    create policy "Authenticated select Employees" on public."Employees"
      for select to authenticated
      using (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'Employees'
      and policyname = 'Authenticated insert Employees'
  ) then
    create policy "Authenticated insert Employees" on public."Employees"
      for insert to authenticated
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'Employees'
      and policyname = 'Authenticated update Employees'
  ) then
    create policy "Authenticated update Employees" on public."Employees"
      for update to authenticated
      using (true)
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'Employees'
      and policyname = 'Authenticated delete Employees'
  ) then
    create policy "Authenticated delete Employees" on public."Employees"
      for delete to authenticated
      using (true);
  end if;
end;
$$;

alter table public."WorkSessions" enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'WorkSessions'
      and policyname = 'Authenticated select WorkSessions'
  ) then
    create policy "Authenticated select WorkSessions" on public."WorkSessions"
      for select to authenticated
      using (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'WorkSessions'
      and policyname = 'Authenticated insert WorkSessions'
  ) then
    create policy "Authenticated insert WorkSessions" on public."WorkSessions"
      for insert to authenticated
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'WorkSessions'
      and policyname = 'Authenticated update WorkSessions'
  ) then
    create policy "Authenticated update WorkSessions" on public."WorkSessions"
      for update to authenticated
      using (true)
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'WorkSessions'
      and policyname = 'Authenticated delete WorkSessions'
  ) then
    create policy "Authenticated delete WorkSessions" on public."WorkSessions"
      for delete to authenticated
      using (true);
  end if;
end;
$$;

alter table public."LeaveBalances" enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'LeaveBalances'
      and policyname = 'Authenticated select LeaveBalances'
  ) then
    create policy "Authenticated select LeaveBalances" on public."LeaveBalances"
      for select to authenticated
      using (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'LeaveBalances'
      and policyname = 'Authenticated insert LeaveBalances'
  ) then
    create policy "Authenticated insert LeaveBalances" on public."LeaveBalances"
      for insert to authenticated
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'LeaveBalances'
      and policyname = 'Authenticated update LeaveBalances'
  ) then
    create policy "Authenticated update LeaveBalances" on public."LeaveBalances"
      for update to authenticated
      using (true)
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'LeaveBalances'
      and policyname = 'Authenticated delete LeaveBalances'
  ) then
    create policy "Authenticated delete LeaveBalances" on public."LeaveBalances"
      for delete to authenticated
      using (true);
  end if;
end;
$$;

alter table public."RateHistory" enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'RateHistory'
      and policyname = 'Authenticated select RateHistory'
  ) then
    create policy "Authenticated select RateHistory" on public."RateHistory"
      for select to authenticated
      using (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'RateHistory'
      and policyname = 'Authenticated insert RateHistory'
  ) then
    create policy "Authenticated insert RateHistory" on public."RateHistory"
      for insert to authenticated
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'RateHistory'
      and policyname = 'Authenticated update RateHistory'
  ) then
    create policy "Authenticated update RateHistory" on public."RateHistory"
      for update to authenticated
      using (true)
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'RateHistory'
      and policyname = 'Authenticated delete RateHistory'
  ) then
    create policy "Authenticated delete RateHistory" on public."RateHistory"
      for delete to authenticated
      using (true);
  end if;
end;
$$;

alter table public."Services" enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'Services'
      and policyname = 'Authenticated select Services'
  ) then
    create policy "Authenticated select Services" on public."Services"
      for select to authenticated
      using (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'Services'
      and policyname = 'Authenticated insert Services'
  ) then
    create policy "Authenticated insert Services" on public."Services"
      for insert to authenticated
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'Services'
      and policyname = 'Authenticated update Services'
  ) then
    create policy "Authenticated update Services" on public."Services"
      for update to authenticated
      using (true)
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'Services'
      and policyname = 'Authenticated delete Services'
  ) then
    create policy "Authenticated delete Services" on public."Services"
      for delete to authenticated
      using (true);
  end if;
end;
$$;

alter table public."Settings" enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'Settings'
      and policyname = 'Authenticated select Settings'
  ) then
    create policy "Authenticated select Settings" on public."Settings"
      for select to authenticated
      using (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'Settings'
      and policyname = 'Authenticated insert Settings'
  ) then
    create policy "Authenticated insert Settings" on public."Settings"
      for insert to authenticated
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'Settings'
      and policyname = 'Authenticated update Settings'
  ) then
    create policy "Authenticated update Settings" on public."Settings"
      for update to authenticated
      using (true)
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'Settings'
      and policyname = 'Authenticated delete Settings'
  ) then
    create policy "Authenticated delete Settings" on public."Settings"
      for delete to authenticated
      using (true);
  end if;
end;
$$;
```

#### Verification helper

- `setup_assistant_diagnostics()` returns one row per table with `has_table`, `rls_enabled`, `missing_policies[]`, and an optional `delta_sql` snippet you can paste back into Supabase if anything is missing.
- The Setup Assistant displays the `delta_sql` output and re-runs the checks whenever you press the verify button so the UI goes green once everything is secured.
#### Verification helper

- `setup_assistant_diagnostics()` returns one row per table with `has_table`, `rls_enabled`, `missing_policies[]`, and an optional `delta_sql` snippet you can paste back into Supabase if anything is missing.
- The Setup Assistant displays the `delta_sql` output and re-runs the checks whenever you press the verify button so the UI goes green once everything is secured.

**Verification:** After running the SQL, return to the Setup Assistant and use the “Verify Policies” button. The routine performs read-only checks to confirm that authenticated requests succeed while anonymous requests receive 401/403 responses. All tables should report a green “Secured” badge before continuing.
4.  **Configure the Runtime API:**
    *   Create `api/local.settings.json` with:
        ---------------------------------------------------------------
        {
          "IsEncrypted": false,
          "Values": {
            "APP_SUPABASE_URL": "https://<metadata-project>.supabase.co",
            "APP_SUPABASE_ANON_KEY": "public-anon-key",
            "APP_SUPABASE_SERVICE_ROLE": "service-role-key-with-org-access"
          }
        }
        ---------------------------------------------------------------
    *   When deploying to Azure Static Web Apps, configure the same keys under the **API** application settings so `/api/config` can serve both bootstrap and organization requests.
5.  **Run the Development App:**
    ---------------------
    npm run electron:dev
    ---------------------
    In a second terminal run `swa start http://localhost:5173 --api-location api` so the `/api/config` function is reachable during development.
    ---------------------
    This will launch the application in a desktop window with hot-reloading.

### Building for Production

1.  **Run the build command:**
    ------------------------
    npm run electron:build
    ------------------------
2.  This command will:
    *   Build the React application into the `/dist` folder.
    *   Package the app with Electron into an executable installer.
3.  The final installer/application will be located in the `/release` directory (which is created outside the project folder).

## 6. Leave Policy & Holiday Management

The leave module centralizes all holiday rules, quotas, and ledger actions so employees, reports, and payroll share one source of truth.

### 6.1. Admin configuration

- The **"חגים וימי חופשה"** screen under Settings edits the `leave_policy` JSON described in Section 3.5.
- Toggles use the following Hebrew microcopy: "אישור חצי יום", "היתרה יכולה לרדת למינוס", "כמות חריגה מימי החופש המוגדרים", "העברת יתרה לשנה הבאה", and "מקסימום להעברה".
- Holiday rows capture a name, date range, and tag selected from:
  - `system_paid` → "חג משולם (מערכת)" (no deduction, payroll marks the day as paid by the organization).
  - `employee_paid` → "חופשה מהמכסה" (deducts from the employee quota).
  - `unpaid` → "לא משולם".
  - `mixed` → "מעורב".
  - `half_day` → "חצי יום" (available only when half-day usage is enabled).
- All persistence must go through Supabase `upsert` on the `Settings` table to avoid duplicate keys.

### 6.2. Employee quota and proration

- Each employee now has an `annual_leave_days` value. The helper `computeEmployeeLeaveSummary` prorates the yearly allowance based on `start_date` and the number of days remaining in the calendar year.
- Carry-over is applied automatically when enabled, capped by `carryover_max_days`.
- Summary data includes `quota`, `used`, `carryIn`, `remaining`, and `adjustments` for consistent display across dashboards.

### 6.3. Recording usage

- The Leave tab provides two quick actions: positive allocations and deductions tied to holiday types.
- Usage inserts a negative `balance` into `LeaveBalances` with a `leave_type` like `usage_employee_paid` or `time_entry_leave_employee_paid`. Allocations insert a positive `balance` with `leave_type='allocation'`.
- When `allow_half_day` is false the UI blocks non-integer deductions. When enabled, half-day holidays auto-fill `-0.5`.
- Negative balances are blocked once the projected balance would drop below `negative_floor_days`; the blocking toast reads **"חריגה ממכסה ימי החופשה המותרים"**.
- `holiday_paid_system` days update payroll tables without inserting a negative ledger entry so paid holidays stay aligned with WorkSessions totals.

### 6.4. Shared selectors

- `selectHolidayForDate(policy, date)` resolves the correct holiday rule for disabling date pickers and tagging payroll rows.
- `selectLeaveRemaining(employeeId, date, context)` calls into `computeEmployeeLeaveSummary` and must be used by Employees, Reports, and Payroll so all surfaces show identical balances.
- The same helpers power unit tests in `test/leave.test.js` to protect proration math and negative-floor enforcement.

## Recent Updates

- Centralized leave policy management via the new Settings screen, including holiday tagging and negative balance controls.
- Employee leave balances now rely on the `LeaveBalances` ledger with annual quota proration and carry-over enforcement.
- Payroll and reports consume the shared leave selectors so paid holidays and remaining days stay aligned across the app.
- Date filters in reports accept manual input or calendar selection and support multiple formats.
- Hours KPI counts time for hourly employees only; employee type filter now includes global staff.
- Detailed entries report can group by employee type with subtotals.

